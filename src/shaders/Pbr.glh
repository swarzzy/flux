
vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f);
}

// TODO: Optimize these

float DistributionGGX(float NdotH, float alphaG)
{
    float NdotHSq = NdotH * NdotH;

    float num = alphaG;
    float denom = (NdotHSq * (alphaG - 1.0f) + 1.0f);
    denom = PI * denom * denom;

    return num / max(denom, 0.001f);
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    // Remapping and squaring roughness for analytical light sources
    // [ Real Shading in Unreal Engine 4 (Brian Karis), Siggraph 2013, p.3]
    float k = ((roughness + 1.0f) * (roughness + 1.0f)) / 8.0f;

    float num = NdotV;
    float denom = NdotV * (1.0f - k) + k;

    return num / denom;
}

float GeometrySmithGGX(float NdotV, float NdotL, float roughness)
{
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

struct PBR
{
    bool metallicWorkflow;
    vec3 V;
    vec3 N;
    vec3 F0;
    float AO;
    vec3 emissionColor;
    // NOTE: Metallic/Specular
    vec3 albedo;
    // NOTE: Metallic
    float metallic;
    float roughness;
};

PBR InitPBRMetallic(vec3 V, vec3 N, vec3 albedo, float metallic, float roughness, float AO)
{
    PBR pbr;
    pbr.metallicWorkflow = true;
    pbr.V = V;
    pbr.N = N;
    pbr.AO = AO;
    pbr.albedo = albedo;
    // TODO: Specify F0 for dielectrics
    vec3 F0 = vec3(0.04f);
    pbr.F0 = mix(F0, albedo, metallic);
    pbr.roughness = roughness;
    pbr.metallic = metallic;
    return pbr;
}

PBR InitPBRSpecular(vec3 V, vec3 N, vec3 albedo, vec3 specular, float gloss, float AO)
{
    PBR pbr;
    pbr.metallicWorkflow = false;
    pbr.V = V;
    pbr.N = N;
    pbr.AO = AO;
    pbr.albedo = albedo;
    pbr.F0 = specular;
    pbr.roughness = gloss;//saturate(1.0f - gloss);
    pbr.metallic = 0.0f;
    return pbr;
}

const float MAX_REFLECTION_LOD = 5.0f;

vec3 Unreal4BRDF(PBR pbr, vec3 L)
{
    vec3 H = normalize(pbr.V + L);

    float NdotV = saturate(dot(pbr.N, pbr.V)) + 1e-5f; // Adding small value to avoid artifacts on edges
    float NdotL = saturate(dot(pbr.N, L));
    float HdotL = saturate(dot(H, L));
    float NdotH = saturate(dot(pbr.N, H));

    float roughness = pbr.roughness;
    float alpha = pbr.roughness;
    float alphaG = pbr.roughness * pbr.roughness;

    vec3 F = FresnelSchlick(HdotL, pbr.F0);
    float D = DistributionGGX(NdotH, alphaG);
    float G = GeometrySmithGGX(NdotV, NdotL, pbr.roughness);

    vec3 num = D * G * F;
    float denom = 4.0f * NdotV * NdotL;
    vec3 specular = num / (denom + 0.05f);

    vec3 refracted = vec3(1.0f) - F;
    refracted *= 1.0f - pbr.metallic;

    // NOTE: Lambertian diffuse brdf
    vec3 diffuse = refracted * pbr.albedo / PI;
    vec3 result = (specular + diffuse) * NdotL;

    return result;
}

vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(1.0f - cosTheta, 5.0f);
}

vec3 IBLIrradance(PBR pbr, samplerCube irradanceMap, samplerCube enviromentMap, sampler2D brdfLut)
{
    float roughness;
    if (pbr.metallicWorkflow)
    {
        roughness = pbr.roughness;
    }
    else
    {
        roughness = 1.0f - pbr.roughness;
    }
    // NOTE: Specular irradance
    float NdotV = saturate(dot(pbr.N, pbr.V));
    vec3 R = reflect(-pbr.V, pbr.N);

    vec3 envIrradance = textureLod(enviromentMap, R, roughness * MAX_REFLECTION_LOD).rgb;
    // TODO: This might be wrong (use NdotL instead?)
    vec3 Fenv = FresnelSchlickRoughness(NdotV, pbr.F0, roughness);
    vec2 envBRDF = texture(brdfLut, vec2(NdotV, roughness)).rg;
    vec3 envSpecular = envIrradance * (Fenv * envBRDF.r + envBRDF.g);

    // NOTE: Diffuse irradance
    vec3 kS = Fenv;
    vec3 kD = vec3(1.0f) - kS;
    kD *= 1.0f - pbr.metallic;
    vec3 diffIrradance = texture(irradanceMap, pbr.N).rgb;
    vec3 diffuse = diffIrradance * pbr.albedo;

    vec3 irradance = (kD * diffuse + envSpecular) * pbr.AO;
    return irradance;
}
